<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>iPad Display</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    body.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
    }

    /* Conteneur principal */
    .display-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
    }

    /* Image */
    .display-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    /* Vid√©o */
    .display-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    /* Couleur (fond) */
    .display-container .color-bg {
      width: 100%;
      height: 100%;
    }

    /* Texte */
    .display-container .text-content {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: white;
      font-size: 4rem;
      font-weight: 300;
      padding: 2rem;
      word-wrap: break-word;
      overflow: hidden;
    }

    /* Status bar (connexion) */
    .status-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 30px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 1rem;
      font-size: 0.7rem;
      z-index: 9999;
      font-family: monospace;
    }

    .status-bar.connected {
      background: rgba(0, 100, 0, 0);
    }

    .status-bar.disconnected {
      background: rgba(100, 0, 0, 0.7);
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
      background: red;
    }

    .status-bar.connected .status-indicator {
      background: lime;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Fallback image anim√©e */
    .fallback-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .fallback-overlay.active {
      display: flex;
    }

    .fallback-text {
      color: rgba(255, 255, 255, 0.5);
      font-size: 2rem;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Barre de statut (affich√©e en dev, cach√©e en prod via CSS si besoin) -->
  <div class="status-bar disconnected" id="statusBar">
    <div>
      <span class="status-indicator"></span>
      <span id="statusText">Connexion...</span>
    </div>
    <div id="debugInfo" style="opacity: 0.6;"></div>
  </div>

  <!-- Conteneur d'affichage -->
  <div class="display-container" id="displayContainer"></div>

  <!-- Overlay fallback -->
  <div class="fallback-overlay" id="fallbackOverlay">
    <div class="fallback-text">‚ö† Pas de signal</div>
  </div>

  <!-- Charger Socket.IO EN PREMIER -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
    /**
     * CLIENT DISPLAY - iPad
     * 
     * Ce client se connecte au serveur via WebSocket et affiche le contenu
     * envoy√© dynamiquement. En cas de perte de connexion, affiche une image
     * de fallback stock√©e localement (via Service Worker).
     */

    class DisplayClient {
      constructor() {
        this.deviceId = this.getDeviceIdFromURL();
        this.socket = null;
        this.currentContent = null;
        this.fallbackTimeout = null;
        this.connectionTimeout = null;
        this.containerEl = document.getElementById('displayContainer');
        this.statusBar = document.getElementById('statusBar');
        this.statusText = document.getElementById('statusText');
        this.debugInfo = document.getElementById('debugInfo');
        this.fallbackOverlay = document.getElementById('fallbackOverlay');

        // Configuration
        this.FALLBACK_IMAGE = '/assets/fallback.svg';
        this.FALLBACK_TIMEOUT = 80800; // 30 secondes
        this.PING_INTERVAL = 5000; // 5 secondes
        this.CONNECTION_TIMEOUT = 10000; // 10 secondes

        this.init();
      }

      /**
       * Extraire l'ID du device depuis l'URL
       */
      getDeviceIdFromURL() {
        const match = window.location.pathname.match(/\/display\/(\d+)/);
        return match ? match[1] : '1';
      }

      /**
       * Initialisation
       */
      async init() {
        // Demander le fullscreen (iOS)
        this.requestFullscreen();

        // Enregistrer le Service Worker pour le cache
        if ('serviceWorker' in navigator) {
          try {
            await navigator.serviceWorker.register('/sw.js');
            console.log('‚úì Service Worker registered');
          } catch (err) {
            console.error('‚úó Service Worker registration failed:', err);
          }
        }

        // Se connecter au serveur
        this.connect();

        // Pinger r√©guli√®rement
        setInterval(() => this.ping(), this.PING_INTERVAL);
      }

      /**
       * Demander le fullscreen (iOS)
       */
      requestFullscreen() {
        document.body.classList.add('fullscreen');
        
        // Demander le fullscreen au premier tap (requis sur iOS)
        const enterFullscreen = async () => {
          try {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
              await elem.requestFullscreen({ navigationUI: 'hide' });
            }
          } catch (err) {
            console.warn('Fullscreen request failed:', err);
          }
          document.removeEventListener('touchstart', enterFullscreen);
        };
        
        document.addEventListener('touchstart', enterFullscreen, { once: true });
      }

      /**
       * Se connecter au serveur via WebSocket
       */
      connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const host = '172.20.10.2';
        const port = window.location.port;
        const url = `${protocol}://${host}:${port}?deviceId=${this.deviceId}`;

        console.log('üîå Connexion WebSocket √†:', url);

        this.socket = io(window.location.origin, {
          query: { deviceId: this.deviceId },
          reconnection: true,
          reconnectionDelay: 1000,
          reconnectionDelayMax: 5000,
          reconnectionAttempts: Infinity,
          transports: ['websocket', 'polling'],
        });

        // √âv√©nements
        this.socket.on('connect', () => this.onConnected());
        this.socket.on('disconnect', () => this.onDisconnected());
        this.socket.on('content-update', (data) => this.onContentUpdate(data));
        this.socket.on('fallback', () => this.showFallback());
        this.socket.on('pong', () => this.onPong());
        
        // Erreurs
        this.socket.on('connect_error', (err) => {
          console.error('‚ùå Erreur connexion WebSocket:', err);
          this.updateStatus('disconnected', 'Erreur connexion');
        });
        
        this.socket.on('error', (err) => {
          console.error('‚ùå Erreur Socket.IO:', err);
        });
      }

      /**
       * Connexion √©tablie
       */
      onConnected() {
        console.log('‚úì Connected to server');
        this.updateStatus('connected', 'Connect√©');
        this.clearFallbackTimeout();
        clearTimeout(this.connectionTimeout);
        this.fallbackOverlay.classList.remove('active');
      }

      /**
       * D√©connect√© du serveur
       */
      onDisconnected() {
        console.log('‚úó Disconnected from server');
        this.updateStatus('disconnected', 'D√©connect√©');
        //this.activateFallbackTimeout();
      }

      /**
       * Mise √† jour du contenu re√ßue
       */
      onContentUpdate(data) {
        console.log('üì¶ Content update:', data);
        this.currentContent = data;
        this.clearFallbackTimeout();
        this.fallbackOverlay.classList.remove('active');

        switch (data.type) {
          case 'image':
            this.displayImage(data.src);
            break;
          case 'video':
            this.displayVideo(data.src, data.duration);
            break;
          case 'color':
            this.displayColor(data.value);
            break;
          case 'text':
            this.displayText(data.value);
            break;
          default:
            this.showFallback();
        }

        // Re-activer le timeout fallback
        //this.activateFallbackTimeout();
      }

      /**
       * Afficher une image
       */
      displayImage(src) {
        this.containerEl.innerHTML = `<img src="${src}" alt="Content" />`;
      }

      /**
       * Afficher une vid√©o
       */
      displayVideo(src, duration) {
        const video = document.createElement('video');
        video.src = src;
        video.autoplay = true;
        video.muted = true;
        video.playsInline = true;
        video.loop = !duration; // Loop si pas de dur√©e
        this.containerEl.innerHTML = '';
        this.containerEl.appendChild(video);
        video.play().catch((err) => console.error('Video play failed:', err));
      }

      /**
       * Afficher une couleur
       */
      displayColor(value) {
        const div = document.createElement('div');
        div.className = 'color-bg';
        div.style.backgroundColor = value;
        this.containerEl.innerHTML = '';
        this.containerEl.appendChild(div);
      }

      /**
       * Afficher du texte
       */
      displayText(value) {
        const div = document.createElement('div');
        div.className = 'text-content';
        div.textContent = value;
        this.containerEl.innerHTML = '';
        this.containerEl.appendChild(div);
      }

      /**
       * Afficher le fallback
       */
      showFallback() {
        console.log('‚ö† Showing fallback');
        this.displayImage(this.FALLBACK_IMAGE);
        this.fallbackOverlay.classList.add('active');
      }

      /**
       * Activer le timeout fallback (30s sans mise √† jour = fallback)
       */
      activateFallbackTimeout() {
        this.clearFallbackTimeout();
        this.fallbackTimeout = setTimeout(() => {
          console.log('‚è± Fallback timeout triggered');
          this.showFallback();
        }, this.FALLBACK_TIMEOUT);
      }

      /**
       * Nettoyer le timeout fallback
       */
      clearFallbackTimeout() {
        if (this.fallbackTimeout) {
          clearTimeout(this.fallbackTimeout);
          this.fallbackTimeout = null;
        }
      }

      /**
       * Ping le serveur pour confirmer la connexion
       */
      ping() {
        if (this.socket && this.socket.connected) {
          this.socket.emit('ping');
        }
      }

      /**
       * R√©ponse au ping
       */
      onPong() {
        this.updateStatus('connected', 'Connect√© ‚úì');
      }

      /**
       * Mettre √† jour la barre de statut
       */
      updateStatus(state, text) {
        this.statusBar.className = `status-bar ${state}`;
        this.statusText.textContent = text;
        this.debugInfo.textContent = `Device ID: ${this.deviceId} | ${new Date().toLocaleTimeString()}`;
      }
    }

    // Lance le client au chargement
    window.addEventListener('DOMContentLoaded', () => {
      new DisplayClient();
    });
  </script>
</body>
</html>
